<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- content-Type -->
<meta charset="utf-8">


<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="renderer" content="webkit|ie-comp|ie-stand">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="language" content="en">
<meta name="robots" content="all">


<meta content="yes" name="apple-mobile-web-app-capable">
<meta content="black" name="apple-mobile-web-app-status-bar-style">
<meta content="telephone=no" name="format-detection">
<meta content="email=no" name="format-detection">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



<meta name="author" content="theme.author, theme.email">
<meta name="reply-to" content="theme.email">
<meta name="owner" content="theme.author">













<meta name="description" content="Nothing special but you">




<meta name="keywords" content="数据结构,排序,">


<meta name="description" content="前言堆排序实质上是选择排序的一种优化：  选择排序：O(n^2)将原始数据集合分为两部分 —— 有序区域和无序区，在无序区中寻找最小值，然后与无序区中第一个进行交换位置，这样不断的缩小无序区大小。 堆排序：O(nlog2^n)使用无序区创建大根堆，然后将根元素与最后一个元素交换位置，相当于不断地找最大元素，将它与无序区最后一个元素交换位置。同样，如果换作小根堆，则可以与选择排序相对应。（选择排序同">
<meta name="keywords" content="数据结构,排序">
<meta property="og:type" content="article">
<meta property="og:title" content="堆排序">
<meta property="og:url" content="http://poberwong.com/2018/10/07/堆排序/index.html">
<meta property="og:site_name" content="Everything you did must be paid one day">
<meta property="og:description" content="前言堆排序实质上是选择排序的一种优化：  选择排序：O(n^2)将原始数据集合分为两部分 —— 有序区域和无序区，在无序区中寻找最小值，然后与无序区中第一个进行交换位置，这样不断的缩小无序区大小。 堆排序：O(nlog2^n)使用无序区创建大根堆，然后将根元素与最后一个元素交换位置，相当于不断地找最大元素，将它与无序区最后一个元素交换位置。同样，如果换作小根堆，则可以与选择排序相对应。（选择排序同">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-03T06:29:39.769Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="堆排序">
<meta name="twitter:description" content="前言堆排序实质上是选择排序的一种优化：  选择排序：O(n^2)将原始数据集合分为两部分 —— 有序区域和无序区，在无序区中寻找最小值，然后与无序区中第一个进行交换位置，这样不断的缩小无序区大小。 堆排序：O(nlog2^n)使用无序区创建大根堆，然后将根元素与最后一个元素交换位置，相当于不断地找最大元素，将它与无序区最后一个元素交换位置。同样，如果换作小根堆，则可以与选择排序相对应。（选择排序同">






  <link rel="shorticon icon" type="image/x-icon" href="/images/favicon.ico?v=0.0.1">






<link href="http://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.0.1">


<script>
(function(){
  var bp = document.createElement('script');
  bp.src = '//push.zhanzhang.baidu.com/push.js';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script>

  <title> 堆排序 </title>
  




</head>
<body lang="zh-Hans">

  <!--[if lte IE 9]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->


  <div class="another-theme layout">

    
<header class="header" id="header">

  <div class="header-cont">
    <div class="text-area">
      
        <h1 class="title" data-text="堆排序"> 堆排序 </h1>

        
        <div class="post-meta">
          <div class="post-time">
            发表于
            <time datetime="2018-10-07T21:18:01+08:00" content="2018-10-07">
              2018-10-07
            </time>
          </div>

          
            <div class="post-category">
              
                <span>
                  <a href="/categories#数据结构与算法" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                

              
            </div>
          

          
            
          
        </div>
        
      
    </div>
    <!-- Navigation -->
    
    <nav class="navigation clearfix" id="navigation">
      
        
        <a class="nav-link" href="/" rel="section">
          首页
        </a>
      
        
        <a class="nav-link" href="/categories" rel="section">
          分类
        </a>
      
        
        <a class="nav-link" href="/tags" rel="section">
          标签
        </a>
      
        
        <a class="nav-link" href="/about" rel="section">
          关于
        </a>
      
    </nav>
    
  </div>
  <div class="mask"></div>
</header>


    <main class="container">

      

  <article class="post-article post-type-normal post" itemscope>

  <div class="post-body">

    <div class="content markdown-body"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>堆排序实质上是选择排序的一种优化：</p>
<ul>
<li>选择排序：<em>O(n^2)</em><br>将原始数据集合分为两部分 —— 有序区域和无序区，在无序区中寻找最小值，然后与无序区中第一个进行交换位置，这样不断的缩小无序区大小。</li>
<li>堆排序：<em>O(nlog2^n)</em><br>使用无序区创建大根堆，然后将根元素与最后一个元素交换位置，相当于不断地找最大元素，将它与无序区最后一个元素交换位置。同样，如果换作小根堆，则可以与选择排序相对应。（选择排序同理）<br>（堆排序主要优化了选择过程的效率）</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>构建大根堆</li>
<li>取根（将根与堆中的最后一个元素做交换）</li>
<li>重新确定新堆的索引范围，调整堆</li>
</ol>
<h3 id="调整堆"><a href="#调整堆" class="headerlink" title="调整堆"></a>调整堆</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 index 开始检查，并保证该位置之下的所有子树均为最大堆</span></span><br><span class="line"><span class="comment"> * @heapSize 堆的大小（元素个数）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">arr, index, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iMax = index, iLeft = <span class="number">2</span> * index + <span class="number">1</span>, <span class="number">2</span> * (index + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span>(iLeft &lt; heapSize &amp;&amp; arr[index] &lt; arr[iLeft]) &#123;</span><br><span class="line">    iMax = iLeft</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(iRight &lt; heapSize &amp;&amp; arr[iMax] &lt; arr[iRight]) &#123;</span><br><span class="line">    iMax = iRight</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(iMax !== index) &#123;</span><br><span class="line">    swap(arr, iMax, index)</span><br><span class="line">    maxHeapify(arr, iMax, heapSize)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arr 表示当前堆的数据集合，index 为当前子树的根，执行结果会保持当前堆的大根堆性质。heapSize 表示当前堆的大小。<br>在不超出堆大小的前提下，调整当前子树的三个节点，保证它为一个大根堆，同时因为如果发生了调整，可能会导致该<strong>子树的大根堆性质遭到破坏</strong>，因此需要对该子树进行递归检查，直至超出堆的总大小（也可以理解为检查到叶子结点了）或者该子树根本不需要调整。</p>
<h3 id="构建大根堆"><a href="#构建大根堆" class="headerlink" title="构建大根堆"></a>构建大根堆</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  将初始的无序数组调整为大根堆, 最小堆的建堆函数相同</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iParent = <span class="built_in">Math</span>.floor((heapSize - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    maxHeapify(arr, i, heapSize)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们的 <code>maxHeapify</code> 函数在调整堆的时候，能够保证被操作的每一棵以下所有子树都保持大根堆的性质，因此我们只要自下而上得执行 <code>maxHeapify</code> 函数，这样在往上走的时候，可以保证子树是最大堆，也满足了 maxHeapify 的逻辑要求。那么如何找到完全二叉树的最底层呢？</p>
<p><em>拓展</em></p>
<blockquote>
<p>层序构建完全二叉树索引于父子之间的关系：<br><strong>从 1 开始编号</strong></p>
<ul>
<li>Parent(i) = floor(i/2)，i 的父节点下标</li>
<li>Left(i) = 2i，i 的左子节点下标</li>
<li>Right(i) = 2i + 1，i 的右子节点下标</li>
</ul>
<p><strong>从 0 开始编号</strong></p>
<ul>
<li>Parent(i) = floor((i-1)/2)，i 的父节点下标</li>
<li>Left(i) = 2i + 1，i 的左子节点下标</li>
<li>Right(i) = 2(i + 1)，i 的右子节点下标</li>
</ul>
</blockquote>
<blockquote>
<p>关于完全二叉树的一些基本性质：</p>
<ol>
<li>二叉树的第 i 层上最多有 2^(i-1) 个结点</li>
<li>在一颗深度为 k 的二叉树中，最多有 2^k - 1 个元素，最少有 k 个结点（斜树或类斜树）</li>
<li>在一颗二叉树中，如果拥有两个孩子（2度）的子树个数为n，则叶子数为 n + 1</li>
<li>在一棵从 1 开始按照层序编号的完全叉树中：（总结点数目为 n）<br>4.1. 如果 i &gt; 1，则结点 i 的双亲的编号为 floor(i/2)<br>4.2. 如果 2i &lt;= n, 则 i 的左孩子编号为 2i，否则没有左孩子<br>4.3. 如果 2i + 1 &lt;= n, 则 i 的右孩子编号为 2i + 1，否则没有右孩子</li>
</ol>
</blockquote>
<ol>
<li>由以上第三点可以推出，当树中不存在一度结点时，整棵树完全由二度结点和叶子组成，也就是说，<code>总结点量 = 2n + 1</code>，由此可以计算出共有 <code>(总量 - 1) / 2</code> 个二度结点, 再减一则为其索引；当存在一度结点时，总结点量= <code>2n + 2</code>，<code>二度结点数 = 总量/2 - 1</code>，而其索引则为 <code>总量/2 - 1 - 1</code>，即 <code>(总量-1) / 2</code>。如果笼统的使用后者，会导致前者不在考虑范围内，不过也是多计算了一次叶子，依然符合调整堆的核心函数要求。</li>
<li>或者由 4.2 推出，当 2i === n 时，i 一定是最后一个拥有左孩子的结点，因此，n / 2 应当是最后一个子树; 可惜，在 Zero-Based 的情况下，4.2 这个定理不成立，因此不介入讨论范围内（数据结构本科课本则是使用 One-Based 来表述的伪码，因此和这里有所出入）</li>
</ol>
<p>由此可得，索引最大值 <code>(heapSize - 1)/2</code> 即是完全二叉树最后一颗子树根所在的位置。 然后使用倒序遍历则可以遍历完树中所有的子树。</p>
<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span> (<span class="params">arr, heapSize</span>) </span>&#123;</span><br><span class="line">  buildMaxHeap(arr, heapSize)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = heapSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i) <span class="comment">// 这里的 i 表示下标</span></span><br><span class="line">    maxHeapify(arr, <span class="number">0</span>, i) <span class="comment">// 这里的 i 表示堆大小</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于小根堆的思考"><a href="#关于小根堆的思考" class="headerlink" title="关于小根堆的思考"></a>关于小根堆的思考</h2><p>在这里构建小根堆和大根堆的逻辑无二，问题就在于入口函数上。大根堆的逻辑是在创建好大根堆之后，将根节点（0）与当前堆的最后一个元素交换，然后不断缩小 heapSize，这样倒序剪叶子, 不会影响之前已经调整好的堆结构。</p>
<p>如果使用小根堆的话，那么在建堆完毕之后，第一个元素就是最小的元素，如果正序缩小范围的话，树结构会被破坏，需要重写调整堆结构的核心子程序。当然，如果是倒序排序的话，小根堆就方便多了。</p>
</div>

    <div class="post-sidebar">
  <div class="toggle-btn" id="toggle-btn">
    <i class="fa fa-reorder"></i>
  </div>
  <section class="post-toc-wrap" id="post-sidebar">
    <h2 class="toc-title">内容目录</h2>
    <div class="post-toc">
      
      
        <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#步骤"><span class="nav-text">步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调整堆"><span class="nav-text">调整堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建大根堆"><span class="nav-text">构建大根堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#入口函数"><span class="nav-text">入口函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于小根堆的思考"><span class="nav-text">关于小根堆的思考</span></a></li></ol></div>
      
    </div>
  </section>
</div>


  </div>

  <footer class="post-footer">
    
      <div class="post-tags">
        
          <a href="/tags#数据结构" rel="tag">#数据结构</a>
        
          <a href="/tags#排序" rel="tag">#排序</a>
        
      </div>
    
    
  <style>
    .donation {
      width: 100%;
      margin-top: 2rem;
    }
    .donation .text {
      color: #333;
      font-size: .8rem;
      cursor: pointer;
      text-decoration: underline;
    }
    .donation .text:hover {
      color: rgb(63,134,181);
    }
    .donation .img-box {
      transition: all .3s;
      width: 0;
      height: 0;
      margin: 1rem auto;
      overflow: hidden;
    }
    .donation .img-box img {
      width: 100%;
      height: 100%;
    }
    .donation #donation {
      display: none;
    }
    .donation #donation:checked + .img-box {
      width: 16rem;
      height: 16rem;
    }
  </style>
  <div class="donation">
    <label class="text" for="donation">
      如果你觉得文章对你有帮助，并且想为我买一杯咖啡，点这里～
    </label>
    <input type="checkbox" name="donation" id="donation">
    <div class="img-box">
      <img src="/images/pay.ali.png" alt="donation">
    </div>
    
  </div>


  </footer>

</article>




      
  <div class="comments" id="comments">
    
  </div>




    </main>

    <footer class="footer clearfix">
  <div class="copyright">
    <span>Copyright</span>
    
    &copy;  2015-
    <span itemprop="copyrightYear">2020</span>
    <span class="author" itemprop="copyrightHolder">Pober Wong</span>
  </div>

  <div class="info">
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
      <span id="showDays" class="show-days"></span>
      <script>
      var birthDay = new Date('7/20/2015');
      var now = new Date();
      var duration = now.getTime() - birthDay.getTime();
      var total= Math.floor(duration / (1000 * 60 * 60 * 24));
      document.getElementById("showDays").innerHTML = "本站已运行 "+total+" 天";
      </script>
      ---
    
    <span id="busuanzi_container_site_pv">
        总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
  </div>

  <div class="my-theme">
    Theme by <a href="//qiutc.me">qiutc</a> | <iframe style="margin-left: 5px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=TongchengQiu&amp;repo=hexo-theme-another&amp;type=star&amp;count=true"></iframe>
  </div>

</footer>


  </div>

  <div class="back-top-btn" id="back-top-btn"><i class="fa fa-chevron-up"></i></div>






  





<script type="text/javascript" src="/js/motto.min.js?v=0.0.1"></script>
<script type="text/javascript" src="/js/main.js?v=0.0.1"></script>


</body>
</html>
